/**===============================
 * FormStorage library 
 * ================================
 * @package form-storage
 * @file form-storage.js
 * @version ${require('../package.json').version}
 * 
 * @author 4X_Pro
 * @email me@4xpro.ru
 * @website https://4xpro.ru
 * @license MIT
 * ================================/

/** Class for forms serializing and deserealizing. 
 * Contains only static methods, form DOM elements is passed as parameter at each call.
 * Supports selects with single and multiple choices, textareas and all types of input.
 * Works correctly with many inputs with same name (for inputs of text type â€” only if "[]" present in the name attribute)
 * Passwords and files from input with type="file" are not saved due to security restrictions.
 * Elements with autocomplete="off" and buttons are ignored.
 * 
 **/
class FormSerializer {
  /** Collects all form data to Javascript objects (but doesn't object to JSON serialzation)
   * 
   * @param {HTMLFormElement} form_element Form element to collect data from
   * @returns {object} JavaScript object where keys are field names and values are field values (or arrays of values, if form contain multiple elements with same name)
   **/
  static serialize(form_element) {
    let data = {};
    for (let i=0, count=form_element.elements.length; i<count; i++) {
      let element = form_element.elements[i];
      if (!element.name) continue; // skipping elements without name attribute
      if (element.getAttribute('autocomplete')==='off') continue; // skipping elements with autocomplete="off" (i.e. CAPTCHA)
      if (element.tagName==='SELECT') {
        data[element.name]=new Array;
        for (let j=0; j<element.selectedOptions.length; j++) data[element.name].push(element.selectedOptions.item(j).value);
      }
      else {
        if (element.tagName!=='BUTTON' && element.type!=='password' && element.type!=='file' && element.type!=='checkbox' && element.type!=='radio' && element.type!=='submit' && element.type!=='button' && element.type!=='reset') {
          if (element.name.includes('[]')) {
            if (!data.hasOwnProperty(element.name)) data[element.name]=new Array();
            data[element.name].push(element.value);
          }
          else data[element.name]=element.value;
        }
        if (element.type==='checkbox') {
          if (!data.hasOwnProperty(element.name)) data[element.name]=new Array();
          if (element.checked) data[element.name].push(element.value);
        }
        if (element.type==='radio' && element.checked===true) data[element.name]=element.value; 
      }
    }
    return data;
  }

  /** Fills form fields with values provided in data object. Fields with missing keys would not be changed. Keys not matching any fields will be ignored.
   * 
   * @param {object} data JavaScript object where keys are field names and values are field values, generated by serialize method
   * @param {HTMLFormElement} form_element Form element to fill with data
   **/
  static unserialize(data,form_element) {
    for (const field in data) {
      const elements = form_element.querySelectorAll('[name="'+field+'"]');
      for (let i=0; i<elements.length; i++) {
        const element = elements[i];
        if (element!==null) {
          if (element.tagName==='SELECT') { // processing select tag
            for (let j=0; j<element.options.length; j++) element.options.item(j).selected=data[field].includes(element.options.item(j).value);
          }
          else { 
            if (element.type!=='password' && element.type!=='file' && element.type!=='checkbox' && element.type!=='radio') { // common elements (like text, date, email and so on)
              element.value=data[field];
            }
            if (element.type==='checkbox') { // checkboxes
              element.checked=data[field].includes(element.value);
            }
            if (element.type==='radio') element.checked=(data[field]==element.value); 
          }
        }
      }
    }
  }
}  

/** Class which controls form data storing and submitting.
 */
class FormStorage {
  /**
   * 
   * @param {HTMLFormElement} form_element 
   * @param {object} options 
   */
  constructor (form_element,options) {
    if (!form_element instanceof HTMLFormElement) throw Error('Parameter form_element is not HTML form!');
    this.form_element = form_element;
    if (typeof(options.storage_key)!=='string') throw Error('Option storage_key is not string!');
    this.storage_key = options.storage_key;

    form_element.addEventListener('submit',this.processFormSubmit.bind(this));
    this.headers = options.headers;
    if (options.wait_input==true) { // if wait_input enabled, start saving only after first input
      this.save_mode = null;  // to avoid saving form after request send
      this.form_element.addEventListener('input',(e) => { if (this.save_mode===null) this.save_mode = true; }); // enabling autosave on first input
    }
    else this.save_mode = true;
    if (options.save_on_exit==undefined) options.save_on_exit = true; // enabling save on exit by default    
    if (options.save_on_exit===true) window.addEventListener('pagehide',this.save.bind(this)); // saving form when user goes away

    if (options.autosave_time===undefined) options.autosave_time=10; // by default, do autosave every 10 seconds
    if (typeof(options.autosave_time)==='number' && options.autosave_time>0) setInterval(this.save.bind(this),1000*options.autosave_time); 

    if (options.skip_autoloading!==true) this.load(); // do initial form loading if is not disabled explicity
  }

  
  processFormSubmit(e) {
    e.preventDefault();
    this.save(); // saving form before sumbitting (mostly to call onSave and onBeforeSave hooks)
    const formData = new FormData(this.form_element);
    const xhr = new XMLHttpRequest();
    xhr.open(this.form_element.method, this.form_element.action, true);
    if (typeof(this.headers)==='object') for (const header in this.headers) xhr.setRequestHeader(header,this.headers[header]);
    const self = this;
    xhr.onload = function() {
      if (xhr.status<400) { 
        window.localStorage.removeItem(self.storage_key); // if status is not error, form is submitted successfully, so removing its data from localStorage
        self.save_mode = false;
      }
      else self.save_mode =  true; // restoring form saving if submitting failed
      this.onSubmitResult(xhr);
    }.bind(this);
    xhr.send(formData); 
  }

  onBeforeSave() {} // hook called before serialization
  onSave(data) {} // hook called before saving, serialized data passed in data parameter
  onLoad(data) {} // hook called before 
  onSubmitResult(xhr) {
    function gotoURL(url) {
      var new_url = new URL(url);
      new_url.hash = '';
      var old_url = new URL(window.location);
      old_url.hash = '';
      window.location.href=url;
      if (new_url.href==old_url.href) window.location.reload(); // if only hash differs in current and new URLs, page reload needs to be forced
    }
    if (xhr.status===200 || xhr.status===206 || xhr.status===204) {
      gotoURL(xhr.responseURL);
    } 
    else if (xhr.status===201 || xhr.status===302 || xhr.status===303) {
      gotoURL(xhr.getResponseHeader('Location'));
    } 
    else {
      this.onSubmitError(xhr);
    }
  }
  onSubmitError(xhr) {
    console.error('Error sending form data:', xhr.statusText);
  }
  onDecodeError(data) {} 

  save() {
    this.onBeforeSave();
    if (this.save_mode) {
      let data = FormSerializer.serialize(this.form_element);
      if (data) {
        this.onSave(data);
        window.localStorage.setItem(this.storage_key,JSON.stringify(data));
      }
    }
  }

  load() {
    let data = window.localStorage.getItem(this.storage_key);
    if (data===null) return; // if no stored data, then nothing to do, just exiting
    try {
      data = JSON.parse(data);
      this.onLoad(data);
      FormSerializer.unserialize(data,this.form_element);
    }
    catch (error) {
      this.onDecodeError(data,error);
    }
  }
}

